# Daily-Sales-Record-CRUD-System
# 1.Introduction
This project is a simple, digital application built in Python (or [Your Language]) designed for small businesses to efficiently manage and track their daily sales data. It implements fundamental CRUD (Create, Read, Update, Delete) operations, facilitating easy data entry, reliable storage, and quick report generation. The system emphasizes modular design and error handling.
# 2.Problem Statement
Small businesses often use manual methods (spreadsheets or physical registers) to track sales, which leads to errors, slow data retrieval, and difficulty generating accurate summaries (e.g., calculating weekly revenue). There is a critical need for a simple, reliable, and digital system to structure, persist, and manage this essential sales data.
# 4.Functional Requirements (FRs)
The project includes three (3) major functional modules:
ID,Module Name,Features & Capabilities
FR1,Sales Record Management (CRUD),"Allows users to Create new records, Read (view) all records, Update existing details (Item, Price, Qty), and Delete records using a unique ID."
FR2,Search & Filtering,Enables users to filter records based on a specific Date Range (Start Date to End Date).
FR3,Reporting & Summary,Calculates and displays the Total Revenue for the currently viewed or filtered sales records.
# 5.Non-functional Requirements (NFRs)
The system meets the following four non-functional requirements:
Usability: The interface (Command Line Interface) is intuitive, with clear menus and prompts for easy user navigation.
Reliability: Sales data is persistently stored in a CSV file, ensuring that data is preserved and can be loaded correctly after the application is closed.
Error Handling: All user inputs (especially for quantity, price, and date format) are validated, providing meaningful messages instead of crashing.
Maintainability: The code is structured using Python modules (sales_manager.py, sales_repository.py) to separate Business Logic, Data Access, and Model layers.
# 6.System Architecture
The project adheres to a 3-Tier Architecture to maintain a clear separation of concerns, which aids in maintainability and testing.
Presentation Layer: Handles user input and displays output (main_app.py).
Business Logic Layer: Contains all core operations (CRUD, filtering, calculation) (sales_manager.py).
Data Access Layer: Manages persistence (reading/writing to the CSV file) (sales_repository.py).
# 7.Design Diagrams
7.1. Use Case Diagram
This shows the high-level interactions between the User (Actor) and the core functions.
7.2. Workflow Diagram
This illustrates the step-by-step process for the critical feature: Creating a New Sales Record.
7.3. Sequence Diagram
This demonstrates the object interaction for the process of Updating an Existing Sales Record.
7.4. Class/Component Diagram
This shows the structure of the Python modules/classes and their dependencies.
7.5. ER Diagram (if storage used)
scince a file is used for presistence, this defines the single entity schema.
. Entity: Sales Record 
. Attributes: SalesID (PK), Date,ItemName,Quantity,UnitPrice,TotalAmount
# 8. Design Decisions & Rationale
Design Decision :Rationale
Language & OOP :"Python was chosen for its simplicity and clear structure, allowing for easy application of Object-Oriented Programming (OOP) principles (classes for SalesRecord, Manager, Repository)."
Data Storage :"A CSV file was chosen over a complex database (e.g., SQL) because it is lightweight, simple to implement, and sufficient for the defined scale (small business) and the Reliability requirement."
Unique ID Generation:"IDs are generated by finding the maximum existing ID and incrementing by one, ensuring uniqueness and data integrity upon every record addition."
# 9. Testing Approach
Testing ensured the system meets both functional and non-functional requirements.
Unit Testing (Manager): Tested core calculations in SalesManager (e.g., calculate_total_revenue to ensure accuracy) and the persistence methods in SalesRepository.
Validation Testing: Tested input validation in main_app to ensure the program rejects non-numeric input for price/quantity and incorrect date formats (YYYY-MM-DD).
CRUD Workflow Testing: Verified that records deleted from memory are correctly removed from the CSV file and that updated records reflect changes after reloading the application.
# 10. Challenges Faced
Ensuring Data Integrity on Save: Handling simultaneous read/write operations and correctly updating the list of records in memory before saving them back to the CSV required careful implementation within the SalesRepository to avoid data corruption.
Robust Date Handling: Implementing the date range filtering required reliable conversion of user input strings into datetime objects to perform accurate comparisons.
# 11. Learnings & Key Takeaways
Practical OOP: Gained practical experience applying OOP principles (Encapsulation and clear separation of classes) to solve a real-world data management problem.
Data Persistence: Mastered the use of standard file I/O operations (CSV) to achieve data persistence for standalone applications.
Structured Development: Practiced a systematic development lifecycle, moving from requirement analysis and modular design to implementation and testing.
# 11. Future Enhancements
Advanced Reporting: Integrate a library (like Pandas) to generate monthly sales trend graphs or export data to Excel format.
User Authentication: Add a simple login mechanism with user roles (Admin/Clerk) to enhance security.
Database Upgrade: Migrate data storage from CSV file to a more scalable solution like a local SQLite database.
